"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const supportMethod = ['get', 'post', 'put', 'all', 'delete', 'patch'];
const ajaxName = 'window._cpi_ajax';
exports.transformer = (context) => {
    let hasController = false;
    const usedIdentifierNames = new Set();
    const transformMethod = (node, prefix) => {
        if (ts.isMethodDeclaration(node)) {
            const [url, method] = resolveUrlAndMethod(node.decorators);
            if (method) {
                const apiArr = [];
                if (prefix !== '') {
                    apiArr.push(prefix);
                }
                if (url !== '') {
                    apiArr.push(url);
                }
                const apiArg = ts.createLiteral(apiArr.join('/').replace(/\/{2, n}/, '/'));
                const methodArg = ts.createLiteral(method);
                const queryArgProperties = [];
                const bodyArgProperties = [];
                const paramArgProperties = [];
                return ts.visitEachChild(node, (cnode) => {
                    if (ts.isParameter(cnode)) {
                        const param = resolveSupportedParam(cnode);
                        if (!param) {
                            return null;
                        }
                        if (param.paramType) {
                            usedIdentifierNames.add(param.paramType);
                        }
                        let assignment;
                        if (param.key) {
                            assignment = ts.createPropertyAssignment(param.key, ts.createIdentifier(param.paramName));
                        }
                        else {
                            assignment = ts.createSpreadAssignment(ts.createIdentifier(param.paramName));
                        }
                        switch (param.decoratorName) {
                            case 'Query':
                                queryArgProperties.push(assignment);
                                break;
                            case 'Body':
                                bodyArgProperties.push(assignment);
                                break;
                            case 'Param':
                                paramArgProperties.push(assignment);
                                break;
                        }
                    }
                    else if (ts.isBlock(cnode)) {
                        const call = ts.createCall(ts.createIdentifier(ajaxName), undefined, [
                            apiArg,
                            methodArg,
                            ts.createObjectLiteral(bodyArgProperties),
                            ts.createObjectLiteral(queryArgProperties),
                            ts.createObjectLiteral(paramArgProperties),
                        ]);
                        return ts.createBlock([ts.createReturn(call)]);
                    }
                    else if (ts.isTypeReferenceNode(cnode)) {
                        const returnTypeNode = cnode.getChildAt(2);
                        if (returnTypeNode) {
                            usedIdentifierNames.add(returnTypeNode.getText());
                        }
                    }
                    return cnode;
                }, context);
            }
        }
        return node;
    };
    const transformController = (node) => {
        if (ts.isClassDeclaration(node)) {
            const prefix = getControllerPrefix(node.decorators);
            if (prefix !== undefined) {
                hasController = true;
                return ts.visitEachChild(node, (cnode) => transformMethod(cnode, prefix), context);
            }
        }
        return node;
    };
    const removeUnused = (node) => {
        if (!hasController) {
            return node;
        }
        if (ts.isDecorator(node)
            || ts.isConstructorDeclaration(node)
            || ts.isPropertyDeclaration(node)) {
            return null;
        }
        else if (ts.isImportDeclaration(node)) {
            const cntNode = node.getChildAt(1);
            if (cntNode) {
                const arr = cntNode.getText().replace(/[\{\}]/g, '').split(',').map((x) => x.trim());
                let unused = true;
                while (arr.length) {
                    const item = arr.pop();
                    unused = unused && !usedIdentifierNames.has(item);
                }
                if (unused) {
                    return null;
                }
            }
        }
        return ts.visitEachChild(node, removeUnused, context);
    };
    return (node) => ts.visitNode(node, (sourceFile) => ts.visitEachChild(ts.visitEachChild(sourceFile, transformController, context), removeUnused, context));
};
function getControllerPrefix(decorators) {
    const arr = decorators
        && decorators.filter((dec) => dec.expression.getChildAt(0).getText().toLowerCase() === 'controller');
    if (arr && arr.length) {
        return arr[0].expression.getChildAt(2).getText().replace(/['"]/g, '') || '';
    }
}
function resolveUrlAndMethod(decorators) {
    const arr = decorators
        .filter((dec) => supportMethod.indexOf(dec.expression.getChildAt(0).getText().toLowerCase()) > -1);
    if (arr.length) {
        const first = arr[0];
        return [
            first.expression.getChildAt(2).getText().replace(/['"]/g, ''),
            first.expression.getChildAt(0).getText(),
        ];
    }
    return [null, null];
}
function resolveSupportedParam(node) {
    const first = node.getChildAt(0);
    const firstMatch = /@(Param|Query|Body)\((.*)\)$/.exec(first && first.getText());
    if (firstMatch) {
        const paramType = node.getChildAt(3);
        return {
            decoratorName: firstMatch[1],
            key: firstMatch[2],
            paramName: node.getChildAt(1).getText(),
            paramType: paramType && paramType.getText(),
        };
    }
}
//# sourceMappingURL=transformer.js.map